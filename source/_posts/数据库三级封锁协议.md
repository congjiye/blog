---
title: 数据库三级封锁协议
date: 2023-09-26 23:42:50
tags: 数据库
category: 理论知识
---

## 前言

数据库三级封锁协议是为了对数据库并发操作进行控制,防止更改丢失,读脏数据,不可重复读等问题.为了解决这类问题引入的解决方案就是加锁,又根据添加锁的种类,设置时间,释放时间的不同分为三种封锁协议.

<!-- more -->

## 锁的种类

在数据库的三级封锁协议中分为两种锁

- 排他锁(exclusive lock,X锁),又称为写锁
- 共享锁(shared lock,S锁),又称为读锁

### 排他锁(X锁)

排他锁,又称为写锁,可以对数据进行读取和修改操作.当一个事务对数据添加X锁时,其他事务都不能对该数据添加锁,即同一时间只有一条事务可以对数据进行修改操作.其他事务只能等待该事务完成后才能对数据进行修改操作.所以我们通常把这类对数据进行修改操作的锁称为写锁.

### 共享锁(S锁)

共享锁,也可以称为读锁.当一个事务对数据添加S锁时,其他事务也可以对数据添加S锁,即所有添加了S锁的事务都可以同时读取数据内容,但是无法对数据进行修改.

## 更改丢失

更改丢失指的是当有多个事务对数据进行操作时,有些事务的操作被其他事务所替代.

![image](https://user-images.githubusercontent.com/41415004/112717687-46409200-8f29-11eb-86c5-dac83dd22bf1.png)

从上图中我们可以看出 T1 事务的修改操作被 T2 事务的修改操作覆盖了.

## 不可重复读

不可重复读指的是某一个事务执行期前其他的事务修改,插入或删除了数据,则该事务在验证数据时会出现与开始结果不一致的情况.

![image](https://user-images.githubusercontent.com/41415004/112717754-9881b300-8f29-11eb-8ed8-c9d9cd2c0b50.png)

## 读脏数据

读脏数据指的是某一个事务读取了另一个事务执行期间的数据内容,当另一个事务回滚时,该事务读取到的内容就是无效数据.

![image](https://user-images.githubusercontent.com/41415004/112717774-af280a00-8f29-11eb-9964-83f41e18ddea.png)

从上图中可以看到 T2 事务读取到的 C 的值是一个无效的数据.

## 三类封锁协议

### 第一类封锁协议

第一类封锁协议指的是在对数据进行修改操作时需要对数据添加X锁.第一类封锁协议相当于把数据的读取和修改看成一个整体,在事务完成之前其他事务都不能对数据进行修改操作.因此第一类封锁协议解决了丢失修改的问题.另外要注意如果其他事务仅是对数据进行读取操作时无需加锁,因此其他事务在执行过程中还是可能会出现不可重复读和读脏数据的情况.

![image](https://user-images.githubusercontent.com/41415004/112717870-4a20e400-8f2a-11eb-8547-4b4ac37ccb6e.png)

上图显示了第一类封锁协议解决丢失修改的问题.

![image](https://user-images.githubusercontent.com/41415004/112717897-7b011900-8f2a-11eb-95db-2fa1ea8c51cb.png)

上图显示了第一类封锁协议出现的读脏数据情况.

![image](https://user-images.githubusercontent.com/41415004/112717911-93713380-8f2a-11eb-9670-0135516c82bb.png)

上图显示了第一类封锁协议出现的不可重复读情况.

### 第二类封锁协议

第二类封锁协议是在第一类封锁协议的基础上加入了S锁.在读取数据前需要对数据添加S锁, `当数据读取完成后释放S锁` .如果一个事务读取数据并添加了S锁,另一个事务添加了X锁,那么添加X锁的那个事务必须等待添加了S锁的事务释放S锁后才能对数据进行修改操作.基于这个缘由第二类封锁协议解决了读脏数据的问题.但是第二类封锁协议并不能解决数据的不可重复读问题.如下图所示.

![image](https://user-images.githubusercontent.com/41415004/112718047-830d8880-8f2b-11eb-9af3-804a722bffe4.png)

### 第三类封锁协议

第三类封锁协议是在第一类封锁协议的基础上加入了S锁,在读取数据前需要对数据添加S锁, `当事务结束后释放S锁`.第三类封锁协议同时解决了数据的修改丢失,不可重复读和读脏数据问题.

**可重复读**
![image](https://user-images.githubusercontent.com/41415004/112718118-e8617980-8f2b-11eb-9167-f1d718387b95.png)

**不读脏数据**
![image](https://user-images.githubusercontent.com/41415004/112718126-f57e6880-8f2b-11eb-842e-c86d255f18fa.png)

## 总结

协议名 | 解决问题 | 不可解决的问题
--|--|--
第一类封锁协议 | 丢失修改 | 读脏数据,不可重复读
第二类封锁协议 | 丢失修改,读脏数据 | 不可重复读
第三类封锁协议 | 丢失修改,读脏数据,不可重复读 | 无

## 声明

本文章的所有图片都来自于 [二级封锁协议-中国科学技术大学](https://wenku.baidu.com/view/8dd9575fcd7931b765ce0508763231126edb77bf.html) 的 PPT 中,如有侵权立即删除.